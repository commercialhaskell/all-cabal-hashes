-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:2b8dc81a827b1851873da85b6b0f677c
    SHA1:d1242957958fdc8eacf27e41fd7927db07c576ce
    SHA256:df86604040ec81f6d152f7e1b0bdf295de06cb4777a2161ba5d7911f20bca5e8
    SHA512:2b1d3a879d48b9ffab4b192843ae8b43dc5a251784e0aade2f59d5a993b827334d3ed4168256525d0bd47fbade51a6aac696cb4e1270a99f0e660cf0aa37821d
    Skein512_512:54c3e1b2898a0da9e6492dba92f3fceb1c16cb60bcfdb50381aac554b5b95ba0eaf40c1832dfed5f31c43fc8645c973579d1f28dbada5e266ac5075baa63ef7c

x-package-locations:
    https://hackage.haskell.org/package/TCache-0.6.5/TCache-0.6.5.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/TCache-0.6.5.tar.gz

x-package-size: 18768
-- END Added by all-cabal-hashes-tool

name:                TCache
version:             0.6.5
synopsis:            A Transactional data cache with configurable persistence
description:
        Data.Tcache is a transactional cache with configurable persistence. It tries to simulate Hibernate
        for Java or Rails for Ruby. The main difference is that transactions are done in memory trough STM.
        There are transactional cache implementations for some J2EE servers like JBOSS.
        .
        TCache uses STM. It can  atomically apply a function to a list of cached objects. The resulting
        objects go back to the cache (withResources). It also can retrieve these objects (getResources).
        Persistence can be syncronous (syncCache)  or asyncronous, wtih configurable time between cache
        writes and configurable cache clearance strategy. the size of the cache can be configured too .
        All of this can be done trough clearSyncCacheProc. Even the TVar variables can be accessed
        directly (getTVar) to acceess all the semantic of atomic blocks while maintaining the persistence of the
        TVar updates.
        .
        Persistence can be defined for each object: Each object must have a defined key, a default filename
        path (if applicable). Persistence is pre-defined in files, but the readResource writeResource and
        delResource methods can be redefined to persist in databases or whatever.
	    .
	    Serialization is also configurable.
        .
        There are  Samples here that explain the main features.
        .

    In this release
    .
    * added withSTMResources. Most of the rest of the methods are derived from withSTMResources .  the results are returned in the STM monad, so  this method can be part of al larger STM transaction
       It also can perforn used defined retries.
    .
    * added modules for cached TMVars
	Data.TCache.TMVar and Data.TCache.TMVar.Dynamic uses TMVars instead of TVars (See Control.Concurrent.STM.TMVar)
    .
        It is not possible tu mix TVars and TMVars packages in the same executable. However code that uses dynamic and non dynamic can
        can be mixed
        .
          * Data.TCache                       - cached TVars of object of type a.
        .
          * Data.TCache.Dynamic           - cached TVars of objects of type IDynamic.
        .
          * Data.TCache.TMVar             - cached TMVars of objects of type a.
        .
          * Data.TCache..TMVar.Dynamic    - cached TMVars of objects of type IDynamic.


category:            Middleware, Data, Database, Concurrency
license:             BSD3
license-file:        LICENSE
author:              Alberto GÃ³mez Corona
maintainer:          agocorona@gmail.com
Tested-With:         GHC == 6.8.2
Build-Type:          Simple
build-Depends:       base >=3 && <4,directory >= 1.0, old-time >=1.0,stm>=2, containers>=0.1.0.1, RefSerialize >= 0.2.4
Cabal-Version:       >= 1.2

exposed-modules:   Data.TCache, Data.TCache.IResource, Data.TCache.Dynamic, Data.TCache.TMVar, Data.TCache.TMVar.Dynamic, Data.TCache.IDynamic
ghc-options:       -O2
