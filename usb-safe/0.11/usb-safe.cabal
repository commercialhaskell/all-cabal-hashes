-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:30933d65d6c1cf653468da26eeeb1bfa
    SHA1:205dc7dfc0377e7fc605b19c42059442da6ea940
    SHA256:249ac74ccee02f4ed501347ff0a6a5e99086331f7f2998fb761b49c6d78ca495
    SHA512:609cbec5a73f7042d0bb44a00faf73a18c7a903c761bc6af8b02d5e10000938c741c15b16682c1626c89055e8793f0edd32ed66a27100cdc1dd6e635a2767c97
    Skein512_512:cef8661f88809067dcf2a4dbf73b7104379713b2172a8a86bb0b9a1243e46646ceb8d1dc2e6389f8450680d41c212dd5974227de64dc887d235907933b7467af

x-package-locations:
    https://hackage.haskell.org/package/usb-safe-0.11/usb-safe-0.11.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/usb-safe-0.11.tar.gz

x-package-size: 14386
-- END Added by all-cabal-hashes-tool

name:          usb-safe
version:       0.11
cabal-version: >=1.6
build-type:    Custom
license:       BSD3
license-file:  LICENSE
copyright:     2009â€“2010 Bas van Dijk
author:        Bas van Dijk <v.dijk.bas@gmail.com>
maintainer:    Bas van Dijk <v.dijk.bas@gmail.com>
stability:     experimental
category:      System, Monadic Regions
synopsis:      Type-safe communication with USB devices.
description:
  The @usb@ package provides a standard Haskell abstraction layer over
  @bindings-libusb@ providing: abstract types instead of @Ptr@s, automatic
  marshalling and unmarshalling, automatic garbage collection,
  exceptions instead of integer return codes, etc..
  .
  While all that is very nice there are still some things that you can
  do wrong. For example doing I/O with a closed device or reading from
  or writing to an endpoint which doesn't belong to the claimed
  interface. Or reading from an Out endpoint or writing to an In
  endpoint.
  .
  @usb-safe@ provides the following guarantees:
  .
  * You can't reference handles to devices that are closed. In other words: no
     I/O with closed handles is possible.
  .
  * The programmer specifies the /region/ in which devices should remain open. On
    exit from the region the opened devices will be closed automatically.
  .
  * You can't reference handles to configurations that have not been set.
  .
  * You can't reference handles to interfaces that have not been claimed.
  .
  * Just like with devices, the programmer can specify the region in
    which interfaces should remain claimed. On exit from the region
    the claimed interfaces will be released automatically.
  .
  * You can't reference handles to alternates that have not been set.
  .
  * You can't reference endpoints that don't belong to a setted alternate.
  .
  * You can't read from an endpoint with an Out transfer direction.
  .
  * You can't write to an endpoint with an In transfer direction.
  .
  * You can't read from or write to endpoints with the unsupported transfer
    types Control and Isochronous. Only I/O with endpoints with the Bulk and
    Interrupt transfer types is allowed.
  .
  The primary technique used in usb-safe is called \"Lightweight monadic
  regions\" which was invented by Oleg Kiselyov and Chung-chieh Shan.
  See:
  .
  <http://okmij.org/ftp/Haskell/regions.html#light-weight>
  .
  This technique is implemented in the @regions@ package which is
  re-exported from @usb-safe@.
  .
  See the @usb-safe-examples@ package for examples how to use this library:
  .
  @darcs get@ <http://code.haskell.org/~basvandijk/code/usb-safe-examples>

source-repository head
  Type:     darcs
  Location: http://code.haskell.org/~basvandijk/code/usb-safe

Library
  GHC-Options: -Wall -fno-warn-orphans
  build-depends: base                      >= 4     && < 4.4
               , base-unicode-symbols      >= 0.1.1 && < 0.3
               , usb                       >= 0.5   && < 0.7
               , usb-enumerator            >= 0.2   && < 0.3
               , iteratee                  >= 0.3.5 && < 0.6
               , bytestring                >= 0.9   && < 0.10
               , regions                   >= 0.8   && < 0.9
               , transformers              >= 0.2   && < 0.3
               , monad-peel                >= 0.1   && < 0.2
  exposed-modules: System.USB.Safe
